\section{Developer Documentation}
\label{sec:devdocs} 

\subsection{Prerequisites}

In order to do development work on \emph{Colonizers}, the following software
is required:
\begin{itemize}
    \item .NET Core 3.1 SDK
    \item Python 3.7
    \item Node.js 10 and NPM 6.4.1
\end{itemize}
The game's UI is designed for a minimum screen resolution of 1920x1080 at
100\% zoom level. It is not recommended to play the game on lower resolution
screens, since graphical errors may occur.

In order to build and run \emph{Colonizers} in Electron, the Electron.NET CLI
package is required. You may install this package as a .NET Core tool by running
the \texttt{dotnet tool install ElectronNET.CLI -g} command. This gives you
access to the \texttt{electronize} command.

It is also highly recommended to use Visual Studio 2019 for development work
on the game engine or the UI. Visual Studio 2019 provides support for debugging
both the UI and the game engine in the same window, which makes for a~seamless
development experience. Visual Studio 2019 is also capable of attaching
to an external process for debugging, which turns out to be
extremely useful with Electron.NET.

For developing and debugging Python AI scripts, the author used Visual Studio Code,
but other software capable of debugging Python scripts is viable as well.

The project can be run by navigating to the project directory of the \texttt{Desktop} project
and running the command \texttt{electronize start}. This will build the application
and start it inside Electron. Building the application is also done with the
\texttt{electronize} command-line tool. if we want to build \emph{Colonizers}
for Windows 64-bit, we would use the command \texttt{electronize build /target win}.
Further documentation for the \texttt{electronize} command-line tool
is available in the documentation for the Electron.NET project \cite{Electronnet}.

\subsection{Project Structure}

The entire game is contained in a .sln (solution) file, which is a file type used
to organize projects in Visual Studio. This solution contains four projects:
\begin{itemize}
    \item \texttt{AICore} --- project with the API for AI scripts and the AICore
        scripts themselves.
    \item \texttt{Desktop} --- project with the UI, consisting of an~Angular
        web application and an ASP.NET Core Web API. The Web API is the
        \emph{ClientApp} subfolder of this project's folder.
    \item \texttt{Game} --- C\# library project containing the game logic
        and code responsible for communicating with Python AIs.
    \item \texttt{Experiments} --- console application project containing
        the experiment scenarios explored in this thesis.
\end{itemize}

The flow of data in the application starts with the UI, since all initiative starts
with the user. The UI then uses the ASP.NET Core Web API to execute game logic.
If required, game logic then talks to processes executing Python AI sripts.
This flow can be seen in \Cref{dd:sequence}.

\begin{figure}[ht]
\centerline{\mbox{\includegraphics[width=130mm]{colonizers-sequence}}}
\caption{\emph{Colonizers} sequence diagram.}\label{dd:sequence}
\end{figure}

The aforementioned components will be discussed in more detail in the following subsections.

\subsection{Game Engine}

This subsection will discuss not only the C\# library implementing the game logic,
but also the ASP.NET Core Web API, since the library is provided to the user Interface
through Web API calls.

\subsubsection{ASP.NET Core Web API}

The Web API consists of controllers, which define REST (Representational
State Transfer) API endpoints. These endpoints are then called by the Angular
application. In order to promote code reusability, functionality was extracted
from controller methods into separate services, which perform more complex operations
such as formulating method calls to the game engine. The following controllers
are present in the project:
\begin{itemize}
    \item \texttt{GameController} is responsible for manipulating game state.
        It contains endpoints for creating new games, perfoming actions during
        gameplay, and for cleaning up after a game is finished.
    \item \texttt{AIController} provides methods for configuring the AI
        scripts in \emph{Colonizers} --- it facilitates adding new AIs
        and changing the Python executable path used to execute AI scripts.
\end{itemize}

The following services are present in the Web API project:
\begin{itemize}
    \item \texttt{FileDialogService} uses the Electron API to open
        file dialogs. These are used to select AIs to add and to
        configure the Python executable path.
    \item \texttt{GameService} makes calls to the game engine library.
        It is responsible for configuring and managing.
    \item \texttt{PlayerService} is responsible for the creation of player
        objects. Since there are three different types of players
        in \emph{Colonizers} (human player, AI script player and an AI folder player),
        their creation is not trivial. Therefore this logic was extracted to this
        service.
    \item \texttt{PythonExecutableService} is responsible for managing
        the path to the used Python executable. Selecting the path every
        time the application restarts would be very inconvenient, therefore
        the application remembers the configured path. This path is stored
        in on disk in the game's installation folder.
    \item \texttt{StateService} only serves to store game state information
        in between API calls from the UI application. This avoids
        unnecessary transfer of JSON data containing the entire game
        state with every API call.
\end{itemize}

The ASP.NET Core Web API also sets up DI (dependency injection) for both itself and
the game engine. ASP.NET Core provides its own DI framework
which is used in this application. The DI is configured in the
\texttt{ConfigureServices} method of the \texttt{Startup} class.
The game engine provides an extension method \texttt{AddColonizersGame}
for easy registration of all its components into DI.

\subsubsection{Game Engine Library}



\subsection{Artificial Intelligence}
\label{chap:aidev}

WORK IN PROGRESS

\subsection{User Interface}

\emph{Colonizers} uses Electron as a means to run the game as a desktop application,
since the game is developed using web technologies. Specifically, it uses the
Electron.NET library, which provides an access to the Electron APIs to C\# applications,
and it also facilitates usage of Electron's build tools to package C\# applications.
C\# and the whole .NET platform in general still do not have a widely-used cross-platform
UI framework, therefore Electron was a good fit for this project.

The UI for \emph{Colonizers} is an Angular application, which is then served inside
Electron. Electron then uses the Chromium rendering engine and Node.js in the background.
The Angular application allows configuration of the game, it handles presentation
of game state to the user, and it is responsible for communicating with the
ASP.NET Core Web API.

In order to do development work on the UI, it is recommended that you use
Visual Studio 2019. It has a very useful feature whereby it allows you to debug
both JavaScript and C\# code at the same time in the same project. Since the Angular
application is located in the same project as the Web API, this is an invaluable
feature. Since the UI is an Angular application, naturally it is possible
to run and debug it without running it in Electron. The source code for this project
contains launch settings pre-configured for Visual Studio 2019 in order to accomplish
exactly this. A sidenote is that while running outside Electron, the application
does not have access to Electron APIs. \emph{Colonizers} uses the File Dialog
API multiple times, therefore this functionality will be unavaliable in this case.
Interaction with the Electron APIs is always preceded by a check whether
the application instance is running inside Electron, therefore calls
to methods which use Electron APIs will not cause exceptions. We can see
such a guard for Electron presence in \Cref{dd:electronguard}.

It is also possible to debug the application while it is running inside Electron.
The command \texttt{electronize start} will launch the application
inside Electron when run. It is then possible to attach to the application's
process in Visual Studio 2019. This allows us to debug code which uses Electron
API calls, which is not possible when not running in Electron. The mentioned
command also has a useful option --- \texttt{electronize start /watch}
which will watch application files
for changes and re-compile only changed application files.

%TODO: enabling top bar and devtools in Electron

\begin{figure}[hb]
\begin{code}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
public async Task<bool> AddSingleScript()
$\{$
    if (HybridSupport.IsElectronActive)
    $\{$
        BrowserWindow mainWindow = Electron.WindowManager
            .BrowserWindows.First();
        OpenDialogOptions options = new OpenDialogOptions
        $\{$
            Properties = new OpenDialogProperty[] $\{$
                    openDialogProperty
                $\}$
        $\}$;

        string[] files = await Electron.Dialog.ShowOpenDialogAsync(
            mainWindow, options);
    $\}$

    return false;
$\}$
\end{code}
\caption{Electron API call guarded by check for Electron presence.}\label{dd:electronguard}
\end{figure}

The source code for the Angular application is written in TypeScript, CSS and HTML.
The HTML used is not pure HTML, rather the HTML files are Angular templates.
Angular Templates are a way to insert data into markup seamlessly.
The TypeScript files are transpiled to JavaScript at build-time.
We use Angular in a client-side mode, whereby the source files are compiled
ahead of time, and are delivered to the client on-demand. Angular also
offers a server-side rendering option, allowing to offload some work
from clients onto servers. However, due to the fact that both client and server
run on the same machine in \emph{Colonizers}, this option was not used.

The most important building blocks of Angular are \emph{Components}.
Components control the view presented to the user, and they prepare
data for presentation by the view. We can see the source code for a component
in \Cref{dd:componentcode}

\begin{figure}[ht]
\begin{code}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
@Component($\{$
    selector: 'app-discard',
    templateUrl: './discard.component.html',
    styleUrls: ['./discard.component.css']
$\}$)
export class DiscardComponent implements OnInit $\{$

    @Input() gameState: GameState;
    @Output() onPick = new EventEmitter<number>();

    constructor() $\{$ $\}$

    ngOnInit() $\{$
    $\}$

    getModules(): Module[] $\{$
        // Find the appropriate modules in the temp discard storage
        return this.gameState.actions.map(
            x => this.gameState.boardState.discardTempStorage
                .find(y => y.name === x.module));
    $\}$

    keep(module: Module) $\{$
        this.onPick.next(this.gameState.actions.findIndex(
            x => x.module == module.name));
    $\}$

$\}$
\end{code}
\caption{An Angular component.}\label{dd:componentcode}
\end{figure}

We can see a few important component features in \Cref{dd:componentcode}:
\begin{itemize}
    \item The definition of the component's template and styles
        in the \texttt{@Component} decorator. Notably, the styles
        specified in this scope only apply to this component's
        template.
    \item The component has an \texttt{@Input()} and an \texttt{@Output()}.
        These are the ways other components interact with this one.
        Keeping component interaction to only inputs and outputs makes
        components pure, meaning they will output the same data
        when provided with the same inputs. In a complex application,
        this is a very desirable property, since it makes debugging
        easier and bugs more rare.
    \item The component defines a selector --- \texttt{app-discard}.
        Using this selector, other components can include this one in
        their templates.
\end{itemize}

We can see an example of the aforementioned component being used in \Cref{dd:componentref}.
The excerpt is from \texttt{GameComponent}'s template, and it demonstrates how
it binds one of its own fields as an input for the \texttt{DiscardComponent},
and that it is listening for events emitted by it.

\begin{figure}[ht]
\begin{code}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
<div *ngIf="isWaitingForHumanPlayer && isDiscardPhase()">
    <app-discard [gameState]="gameState"
                 (onPick)="onHumanPlayerAction(\$event)">
    </app-discard>
</div>
\end{code}
\caption{Usage of Angular component in another component's template.}\label{dd:componentref}
\end{figure}

These features are the core of how the UI application is built --- it is based on
a~divide-and-conquer principle, where the entire view is composed of smaller components,
which are in turn composed of even smaller components.

Another notable building block of \texttt{Colonizers} is the usage of Angular
services. A service in Angular is meant to be a way to abstract data manipulation
and API calls away from components. Therefore, all code pertaining to
communication with the ASP.NET Core Web API is contained within
the two service classes --- \texttt{GameService} and \texttt{ScriptsService}.

\subsection{Experiments}
\label{chap:experimentdocs}

The experiments performed in this thesis are implemented in the \texttt{Experiments}
project of the \texttt{Colonizers} solution. It is a C\# console application project.
It is invoked via the command line with two arguments --- the first is a~number
between 1 and 5, corresponding to the experiment number, and the second
is the path to the Python executable to use when executing AI scripts.

% TODO: verify where the JSON file is generated
After the experiment is run, it will produce a JSON file containing the results
of the experiment. This file is generated in the directory where the experiments
are running.
\Cref{dd:experimentjson} shows the structure of these JSON files, with less
important fields omitted for brevity. The JSON files associated with the five
experiments are also located in the \texttt{Experiments} projects, namely in
the \texttt{Results} folder. They were added there for reference, since
some experiments may take tens of hours to run even on reasonably fast
machines. Be aware that a simple diff of the JSON result files
is not sufficient for determining whether or not a given experiment was successfully
replicated. This is because the files contain running times of the games as well.

\begin{figure}[ht]
\begin{code}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
$\{$
    "Players": [
        "Name": "ISMCTS",
        "PlayerEndInfo": $\{$
            "Ranking": 3,
            "VictoryPoints": 24,
            "Player": $\{$
                "ID": 1,
                ...
            $\}$
        $\}$
    ],
    "Duration": "00:12:28.1879334"
$\}$
\end{code}
\caption{Experiment result JSON file structure (simplified).}\label{dd:experimentjson}
\end{figure}

The class \texttt{Scenarios} contains the setup for the experiments,
and each scenario then calls \texttt{ExperimentRunner} to performed
the experiment itself.

A noteworthy point is the implementation of the shuffling of players between games.
Since the game engine already possessed an implementation of the Fisher-Yates Shuffle
\cite{Knuth98} for shuffling lists, this implementation was reused for shuffling the
players themselves. This means that if we were to run the experiments
without shuffling, and instead assigning the players the same positions they would
have been assigned by the shuffle, the results of this experiment would be different.
This is because running the shuffle manipulates the game engine's random number generator.
